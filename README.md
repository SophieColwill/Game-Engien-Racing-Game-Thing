# State Machine
The state machine implementation in my project is, while unconventional, is implemented to help player movement. While in the original game, the player had to swerve through 5 lanes of traffic, my implementation has it shrunk down to 3 that the player can switch between. It works by storing 3 different Vector3s within the code files, and when A / D is pressed, it moves the Triangle (Car replacement) onto that movement lane. The reason I did this, was because I noticed how the enemy traffic seemed to stick to 5 really distinct lanes of movement, meaning that, to recreate the feel of the game, all I needed was the vehicle on a track. Therefore, it was a great way to implement each path as a different state that can be built apon to handle its own enemies.

# Observer
The observer methods used within the project, I think is a very good use of it. While watching a video of the copied game, I noticed that multiple things used a tick speed. So I thought that, if I wanted to make such trackers modular so that I don't need to worry about hard coding them into my player in case of future changes, I could add them to the player script as Observers to make it more organised. So, one observer changes the fuel amount (Displayed by the orange / blue bar on the bottom right side) and another observer handles seconds and minutes (The text displayed at the top right). When the player runs out of fuel, the build closes, same with pressing escape.

# Object Pooling
I used object pooling on all the enemy cars as they would need to be spawned and despawned periodically, specifically despawning when ran into or off the screen. I implemented it by adding it to the script of each state machine, but only the collision code into the "handle" function. This way each road section could handle it's own cars, and handle it's own collisions only when the player is actively on that segment of the road. It works by first spawning 3 cars per lane then making them invisible imidiatly. After a random interval of time, it will make one of them visible and move it to the top of the lane off screen. Once activated, it will start to move at a constant rate down until off screen, and once off screen it will turn invisible and stop moving down, awaiting to be called again.

# Dirty Flag
I used the Dirty Flag method in the fuel since it is the only changing variable. Whenever fuel changes, whether on a car collision or fuel tick, it will call the CarFuel variable. That variable will then change the _carFuel variable and set the object to "dirty". Once dirty, in update, it will then set the value of the fuel slider on the bottom right hand side of the screen to the current car fuel.

<img width="699" height="389" alt="Screenshot 2025-10-30 181719" src="https://github.com/user-attachments/assets/8022b2f5-ef45-4265-9937-5d6df91a7584" />
